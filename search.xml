<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux技能</title>
      <link href="/2020/01/03/linux-ji-neng/"/>
      <url>/2020/01/03/linux-ji-neng/</url>
      
        <content type="html"><![CDATA[<hr><p>title: Linux技能<br>date: 2019-12-30 17:30:37<br>categories:<br>    - Linux<br>tags:<br>    - linux<br>index_img: <a href="http://img2.imgtn.bdimg.com/it/u=1362014025,3455045187&amp;fm=26&amp;gp=0.jpg" target="_blank" rel="noopener">http://img2.imgtn.bdimg.com/it/u=1362014025,3455045187&amp;fm=26&amp;gp=0.jpg</a><br>banner_img: <a href="http://img2.imgtn.bdimg.com/it/u=1362014025,3455045187&amp;fm=26&amp;gp=0.jpg" target="_blank" rel="noopener">http://img2.imgtn.bdimg.com/it/u=1362014025,3455045187&amp;fm=26&amp;gp=0.jpg</a><br>[TOC]</p><h2 id="1-请执行命令取出linux中eth0的IP地址"><a href="#1-请执行命令取出linux中eth0的IP地址" class="headerlink" title="1. 请执行命令取出linux中eth0的IP地址"></a>1. 请执行命令取出linux中eth0的IP地址</h2><pre><code>方法1：ifconfig eth0| grep &#39;inet addr&#39;| awk -F&quot;:&quot; &#39;{print $2}&#39;|awk &#39;{print $1}&#39;方法2：ifconfig eth0| grep &#39;inet addr&#39;| cut -d: -f2|cut -d&quot; &quot; -f1方法3：ifconfig eth0| grep &#39;inet addr&#39;| cut -d: -f2| awk &#39;{print $1}&#39;方法4：ifconfig eth0| awk -F &#39;[ :]+&#39; &#39;NR==2 {print $4}&#39;</code></pre><h2 id="2-统计apache日志单ip访问请求数排名"><a href="#2-统计apache日志单ip访问请求数排名" class="headerlink" title="2. 统计apache日志单ip访问请求数排名"></a>2. 统计apache日志单ip访问请求数排名</h2><pre><code>方法1：awk &#39;{S[$1]++} END {for(a in S) print S[a],a}&#39; access.log |sort -rn -k2方法2：awk &#39;{print $1}&#39; access.log |sort |uniq -c |sort -rn方法3: sed &#39;s/- -.*$//g&#39; access.log |sort |uniq -c |sort -rn</code></pre><h2 id="3-处理以下文件内容-将域名取出并根据域名进行计数排序处理-百度和sohu面试题"><a href="#3-处理以下文件内容-将域名取出并根据域名进行计数排序处理-百度和sohu面试题" class="headerlink" title="3. 处理以下文件内容,将域名取出并根据域名进行计数排序处理(百度和sohu面试题)"></a>3. 处理以下文件内容,将域名取出并根据域名进行计数排序处理(百度和sohu面试题)</h2><blockquote><pre><code>[root@ywxi test]# cat oldboy.log http://www.etiantian.org/index.htmlhttp://www.etiantian.org/1.htmlhttp://post.etiantian.org/index.htmlhttp://mp3.etiantian.org/index.htmlhttp://www.etiantian.org/3.htmlhttp://post.etiantian.org/2.html</code></pre></blockquote><pre><code>方法1： cut -d &quot;/&quot; -f3 test.log |sort |uniq -c    方法2： awk -F &quot;/&quot; &#39;{print $3}&#39; test.log |sort |uniq -c方法3： sed &#39;s#^http://##g&#39; test.log|sed &#39;s#/.*##g&#39;|sort |uniq -c方法4： cat test.log |tr &quot;\/&quot; &quot;\n&quot;|grep etiantian|sort|uniq -c方法5： sed -e &#39;s#^.*//\(.*etiantian.*\)/.*html#\1#g&#39; test.log|sort|uniq -c|sort方法6： cut -d &quot;/&quot; -f 3 test.log |awk &#39;{S[$1]++} END {for(a in S) print S[a],a}&#39;方法7： awk -F &quot;/&quot; &#39;{++S[$3]} END {for(key in S) print S[key],key}&#39; test.log方法8： awk -F &#39;[:/]+&#39; &#39;{print $2}&#39; test.log |sort |uniq -c</code></pre><h2 id="4-找出当前目录下包含127-0-0-1关键字的文件"><a href="#4-找出当前目录下包含127-0-0-1关键字的文件" class="headerlink" title="4. 找出当前目录下包含127.0.0.1关键字的文件"></a>4. 找出当前目录下包含127.0.0.1关键字的文件</h2><pre><code>方法1: grep -rl &#39;127.0.0.1&#39; ./方法2: awk &#39;/127.0.0.1/{print FILENAME}&#39; `find -type f`方法3: find -type f |xargs grep “127.0.0.1”方法4: find -type f -exec grep “127.0.0.1” {} \;</code></pre><h2 id="5-删除jfedu-txt行前和行尾的任意空格"><a href="#5-删除jfedu-txt行前和行尾的任意空格" class="headerlink" title="5. 删除jfedu.txt行前和行尾的任意空格"></a>5. 删除jfedu.txt行前和行尾的任意空格</h2><pre><code>sed ‘s/^[ \t]*//；s/[ \t]*$//’ jfedu.txt</code></pre><h2 id="6-将root和bash动作替换"><a href="#6-将root和bash动作替换" class="headerlink" title="6. 将root和bash动作替换"></a>6. 将root和bash动作替换</h2><pre><code>sed -ne ‘s/root/admin/’ -ne ‘s/bash/sh/p’ /etc/passwd</code></pre><h2 id="7-在每行开头插入-号-，直接修改源文件"><a href="#7-在每行开头插入-号-，直接修改源文件" class="headerlink" title="7. 在每行开头插入#号 ，直接修改源文件"></a>7. 在每行开头插入#号 ，直接修改源文件</h2><pre><code>sed -i ‘s/^/#/’ /etc/passwd</code></pre><h2 id="8-将第1-5行内容迁移至末尾"><a href="#8-将第1-5行内容迁移至末尾" class="headerlink" title="8. 将第1~5行内容迁移至末尾"></a>8. 将第1~5行内容迁移至末尾</h2><pre><code>sed ‘1,5(H:d);$G’ test.txt</code></pre><h2 id="9-显示-etc-passwd文件中不以-bin-bash结尾的行"><a href="#9-显示-etc-passwd文件中不以-bin-bash结尾的行" class="headerlink" title="9.  显示/etc/passwd文件中不以/bin/bash结尾的行"></a>9.  显示/etc/passwd文件中不以/bin/bash结尾的行</h2><pre><code>cat /etc/passwd |grep -v /bin/bash$</code></pre><h2 id="10-找出-etc-passwd中的两位或三位数"><a href="#10-找出-etc-passwd中的两位或三位数" class="headerlink" title="10. 找出/etc/passwd中的两位或三位数"></a>10. 找出/etc/passwd中的两位或三位数</h2><pre><code>grep -o &quot;\&lt;[1-9][0-9]\{1,2\}\&gt;&quot; /etc/passwd|sort -nr|uniq</code></pre><h2 id="11-查找root和sshd的行"><a href="#11-查找root和sshd的行" class="headerlink" title="11. 查找root和sshd的行"></a>11. 查找root和sshd的行</h2><pre><code>grep -e ‘root’ -e ’sshd’ /etc/passwd</code></pre><h2 id="12-过滤文件中空白行与-开头的行"><a href="#12-过滤文件中空白行与-开头的行" class="headerlink" title="12.  过滤文件中空白行与#开头的行"></a>12.  过滤文件中空白行与#开头的行</h2><pre><code>egrep -v ‘^$|^#’ /etc/passwd</code></pre><h2 id="13-显示三个用户root、-mage、-wang的UID和默认shell"><a href="#13-显示三个用户root、-mage、-wang的UID和默认shell" class="headerlink" title="13. 显示三个用户root、 mage、 wang的UID和默认shell"></a>13. 显示三个用户root、 mage、 wang的UID和默认shell</h2><pre><code>egrep &quot;^((root)|(mage)|(wang)\&gt;)&quot; /etc/passwd</code></pre><h2 id="14-查文件大小大于1Mb的文件"><a href="#14-查文件大小大于1Mb的文件" class="headerlink" title="14. 查文件大小大于1Mb的文件"></a>14. 查文件大小大于1Mb的文件</h2><pre><code>find /data/ -size +1M</code></pre><h2 id="15-查文件类型并将权限设置为644"><a href="#15-查文件类型并将权限设置为644" class="headerlink" title="15. 查文件类型并将权限设置为644"></a>15. 查文件类型并将权限设置为644</h2><pre><code>find /data/ -type f|xargs chmod 644 -R</code></pre><h2 id="16-查找-data-目录以大写字母开头的文件"><a href="#16-查找-data-目录以大写字母开头的文件" class="headerlink" title="16. 查找/data/目录以大写字母开头的文件"></a>16. 查找/data/目录以大写字母开头的文件</h2><pre><code>find /data/ -name “[A-Z]*” </code></pre><h2 id="17-在-home下查最近两天内改动过的文件"><a href="#17-在-home下查最近两天内改动过的文件" class="headerlink" title="17.  在/home下查最近两天内改动过的文件"></a>17.  在/home下查最近两天内改动过的文件</h2><pre><code>find /home  -mtime   -2 </code></pre><h2 id="18-查找在系统中属于FRED这个用户的文件"><a href="#18-查找在系统中属于FRED这个用户的文件" class="headerlink" title="18. 查找在系统中属于FRED这个用户的文件"></a>18. 查找在系统中属于FRED这个用户的文件</h2><pre><code>find /   -user    fred</code></pre><h2 id="19-输出以冒号为分隔的-etc-passwd文件中记录的字段段数"><a href="#19-输出以冒号为分隔的-etc-passwd文件中记录的字段段数" class="headerlink" title="19. 输出以冒号为分隔的/etc/passwd文件中记录的字段段数"></a>19. 输出以冒号为分隔的/etc/passwd文件中记录的字段段数</h2><pre><code>awk -F: &#39;{print $0,NF}&#39; /etc/passwd</code></pre><h2 id="20-输出以冒号为分隔符，以root开头的行第一列，且在前面插入“Hi-”"><a href="#20-输出以冒号为分隔符，以root开头的行第一列，且在前面插入“Hi-”" class="headerlink" title="20. 输出以冒号为分隔符，以root开头的行第一列，且在前面插入“Hi,”"></a>20. 输出以冒号为分隔符，以root开头的行第一列，且在前面插入“Hi,”</h2><pre><code>awk -F: &#39;/^root/{print &quot;Hi,&quot; $1}&#39; /etc/passwd</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker&amp;部署</title>
      <link href="/2019/12/30/docker-bu-shu/"/>
      <url>/2019/12/30/docker-bu-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-docker-engine---community" target="_blank" rel="noopener">官方文档</a></p><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><ol><li>安装所需的软件包。yum-utils提供了yum-config-manager 效用，并device-mapper-persistent-data和lvm2由需要 devicemapper存储驱动程序。<pre><code>$ sudo yum install -y yum-utils \device-mapper-persistent-data \lvm2</code></pre></li><li>使用以下命令来设置稳定的存储库</li></ol><pre><code>$ sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><ol start="3"><li>安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本</li></ol><pre><code>$ sudo yum install docker-ce docker-ce-cli containerd.io</code></pre><ol start="4"><li>启动docker</li></ol><pre><code>$ sudo systemctl start docker</code></pre><ol start="5"><li>通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</li></ol><pre><code>$ sudo docker run hello-world</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7下Django安装</title>
      <link href="/2019/12/30/linux-django-an-zhuang/"/>
      <url>/2019/12/30/linux-django-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="linux-django"><a href="#linux-django" class="headerlink" title="linux django"></a>linux django</h3><pre><code>安装django1、pip3 install django 2、django-admin startproject mypro 报错：bash: django-admin: command not found...解决：python3 /usr/local/python3/lib/python3.7/site-packages/django/bin/django-admin.py startproject mypro3、cd mypro4、python manage.py startapp app报错 ：找不到sqlite解决步骤：①yum -y install sqlite-devel②切换到Python-3.7.4③执行：./configure --prefix=/usr/local/python3④make⑤如果没有权限：sudo make install // 有权限：make install5、python manage.py startapp app报错：sqlite版本问题解决步骤：1、cd ~wget https://www.sqlite.org/2019/sqlite-autoconf-3270200.tar.gztar -zxvf sqlite-autoconf-3270200.tar.gzcd sqlite-autoconf-3270200./configure --prefix=/usr/localmake make install2、find /usr/ -name sqlite3cd ~ls删除没有用的文件rm -rf sqlite-autoconf-3270200.tar.gzrm -rf sqlite-autoconf-3270200更改旧的sqlite3mv /usr/bin/sqlite3  /usr/bin/sqlite3_old软链接将新的sqlite3设置到/usr/bin目录下ln -s /usr/local/bin/sqlite3   /usr/bin/sqlite3将路径传递给共享库export LD_LIBRARY_PATH=&quot;/usr/local/lib&quot;查看sqlite3有没有更新成功：python3import sqlite3sqlite3.sqlite_version     3.27.1启动djangocd mypropython3 manage.py runserver</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos下MongoDB部署</title>
      <link href="/2019/12/30/centos-xia-mongodb-bu-shu/"/>
      <url>/2019/12/30/centos-xia-mongodb-bu-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p><a href="https://blog.csdn.net/maoyuanming0806/article/details/83247616" target="_blank" rel="noopener">博客地址</a></p><h3 id="官网yum安装（推荐–-gt-快速部署）"><a href="#官网yum安装（推荐–-gt-快速部署）" class="headerlink" title="官网yum安装（推荐–&gt;快速部署）"></a>官网yum安装（推荐–&gt;快速部署）</h3><pre><code>centos安装MongoDB：1.touch /etc/yum.repos.d/mongodb-org-4.2.repo2.vim /etc/yum.repos.d/mongodb-org-4.2.repo3.配置[mongodb-org-4.2]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc4. :wq5.安装yum install -y mongodb-org启动服务的方式：1.前台运行mongod如果报 /data/db not foundmkdir -p /data/dbmongod2.在后台启动①--fork启动mongod --fork --logpath=/var/log/mongodb.log②以配置文件启动mongomkdir -p /etc/mongotouch /etc/mongo/mongod.confvim /etc/mongo/mongod.confport=27017  dbpath=/data/db  logpath=/var/log/mongodb.log  logappend=true  fork=true  :wq启动：mongod -f /etc/mongo/mongod.conf3.用服务启动mongoservice mongod start查看正在运行的进程：netstat -tpl杀死进程kill -9 进程号还可以killall mongodmongoDB 基本命令查看数据库： show dbs;查看表： show tables;查看表内容： db.&#39;表名&#39;.find()推出粗： exit  --不加括号</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux四剑客</title>
      <link href="/2019/12/30/linux-si-jian-ke/"/>
      <url>/2019/12/30/linux-si-jian-ke/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h2><blockquote><p>查询命令，就是find</p></blockquote><pre><code>用法: find usage: find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]       find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]</code></pre><ul><li><strong>常用参数</strong></li></ul><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>-name</td><td>file</td><td>查找名为file的文件</td></tr><tr><td>-type</td><td>b/d/c/p/l/f</td><td>查是块设备、目录、字符设备、管道、符号链接、普通文件</td></tr><tr><td>-size</td><td>n[c]</td><td>查长度为n块[或n字节]的文件</td></tr><tr><td>-perm</td><td></td><td>按执行权限来查找</td></tr><tr><td>-user</td><td>username</td><td>按文件属主来查找</td></tr><tr><td>-group</td><td>groupname</td><td>按组来查找</td></tr><tr><td>-mtime</td><td>-n +n</td><td>按文件更改时间来查找文件，-n指n天以内，+n指n天以前</td></tr><tr><td>-atime</td><td>n +n</td><td>按文件访问时间来查找文件</td></tr><tr><td>-ctime</td><td>-n +n</td><td>按文件创建时间来查找文件</td></tr><tr><td>-mmin</td><td>-n +n</td><td>按文件更改时间来查找文件，-n指n分钟以内，+n指n分钟以前</td></tr><tr><td>-amin</td><td>-n +n</td><td>按文件访问时间来查找文件</td></tr><tr><td>-cmin</td><td>-n +n</td><td>按文件创建时间来查找文件</td></tr><tr><td>-nogroup</td><td></td><td>查无有效属组的文件</td></tr><tr><td>-nouser</td><td></td><td>查无有效属主的文件</td></tr><tr><td>-newer</td><td>f1 !f2</td><td>找文件，-n指n天以内，+n指n天以前</td></tr><tr><td>-depth</td><td></td><td>使查找在进入子目录前先行查找完本目录</td></tr><tr><td>-fstype</td><td></td><td>查更改时间比f1新但比f2旧的文件</td></tr><tr><td>-mount</td><td></td><td>查文件时不跨越文件系统mount点</td></tr><tr><td>-follow</td><td></td><td>如果遇到符号链接文件，就跟踪链接所指的文件</td></tr><tr><td>-cpio</td><td></td><td>查位于某一类型文件系统中的文件</td></tr><tr><td>-prune</td><td></td><td>忽略某个目录</td></tr><tr><td>-maxdepth</td><td></td><td>查找目录级别深度</td></tr></tbody></table><ul><li><p><strong>-name</strong></p><pre><code>find /home/ -name &#39;file&#39;    # 查询home目录下文件名为file的文件find /home/ -name &#39;[a-z]*&#39;  # 查找home目录下文件名以小写字母开头的文件</code></pre></li><li><p><strong>-type</strong></p><pre><code>find /home/ -type d     # 查找home目录下的目录find /home/ ! -type d   # 查找home目录下的非目录find /home -type d | xargs chmod 755 -R     # 查找home目录下的目录，并将这个目录里的文件的权限设置为755</code></pre></li><li><p><strong>-size</strong></p><pre><code>find /home/ -size +1K   # 查找home目录下文件大于1K的文件find /home/ -size -1M   # 查找home目录下文件小于1M的文件find /home/ -size 10K   # 查找home目录下文件等于10K的文件</code></pre></li><li><p><strong>-perm</strong></p><pre><code># 减号代表的意思是 比当前775更充足的权限 所有1的部分必须被匹配find /home/ -perm -775  # 加号代表的意思是 只要有权限位置符合查询条件即可find /home/ -perm +001# 查询 644的文件及目录find /home/ -perm 644</code></pre></li></ul><h2 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h2><blockquote><p>Global search regular expression</p><p>全局    搜索    正则    表达式</p></blockquote><pre><code>usage: grep [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]    [-e pattern] [-f file] [--binary-files=value] [--color=when]    [--context[=num]] [--directories=action] [--label] [--line-buffered]    [--null] [pattern] [file ...]</code></pre><table><thead><tr><th>常用参数</th><th></th></tr></thead><tbody><tr><td>-a</td><td>以文本文件方式搜索</td></tr><tr><td>-c</td><td>计算找到的符合行的次数</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>顺便输出行号</td></tr><tr><td>-v</td><td>反向选择，即显示不包含匹配文本的所有行</td></tr><tr><td>-h</td><td>查询多文件时不显示文件名</td></tr><tr><td>-l</td><td>查询多文件时只输出包含匹配字符的文件名</td></tr><tr><td>-s</td><td>不显示不存在或无匹配文本的错误信息</td></tr><tr><td>-E</td><td>允许使用egrep扩展模式匹配。</td></tr></tbody></table><table><thead><tr><th>常用通配符</th><th></th></tr></thead><tbody><tr><td>*</td><td>0个或者多个字符、数字</td></tr><tr><td>?</td><td>匹配任意一个字符</td></tr><tr><td>#</td><td>表示注解</td></tr><tr><td>|</td><td>管道符号</td></tr><tr><td>;</td><td>多个命令连续执行</td></tr><tr><td>&amp;</td><td>后台运行指令</td></tr><tr><td>!</td><td>逻辑运算非</td></tr><tr><td>[]</td><td>内容范围，匹配括号中内容</td></tr><tr><td>{}</td><td>命令块，多个命令匹配</td></tr></tbody></table><table><thead><tr><th>正则表达式</th><th></th></tr></thead><tbody><tr><td>*</td><td>前一个字符匹配0次或多次</td></tr><tr><td>+</td><td>前面的正则表达式1次或多次</td></tr><tr><td>?</td><td>前面的正则表达式出现0次或多次</td></tr><tr><td>^</td><td>匹配行首，即以某个字符开头</td></tr><tr><td>$</td><td>匹配行尾，即以某个字符结尾</td></tr><tr><td>\(..\)</td><td>标记匹配字符</td></tr><tr><td>[]</td><td>匹配中括号里的任意指定字符，但只匹配一个字符</td></tr><tr><td>[^]</td><td>匹配除中括号以外的任意一个字符</td></tr><tr><td>\</td><td>转义符，取消特殊含义</td></tr><tr><td>\&lt;</td><td>锚定单词的开始</td></tr><tr><td>\&gt;</td><td>锚定单词的结束</td></tr><tr><td>{n}</td><td>匹配字符出现n次</td></tr><tr><td>{n,}</td><td>匹配字符出现大于等于n次</td></tr><tr><td>{n,m}</td><td>匹配字符至少出现n次，最多出现m次</td></tr><tr><td>\w</td><td>匹配文字和数字字符</td></tr><tr><td>\W</td><td>\w的反置形式，匹配一个或多个非单词字符</td></tr><tr><td>\b</td><td>单词锁定符</td></tr><tr><td>\s</td><td>匹配任何空白字符</td></tr><tr><td>\d</td><td>匹配一个数字字符，等价于[0-9]</td></tr></tbody></table><p>练一个</p><blockquote><p>查询文件ip地址</p></blockquote><h2 id="Awk"><a href="#Awk" class="headerlink" title="Awk"></a>Awk</h2><blockquote><p>AWK是一个优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。</p><p>以Aho、Weinberger、Kernighan三位发明者名字首字母命名为AWK，AWK是一个行级文本高效处理工具。</p><p>AWK经过改进生成的新的版本有Nawk、Gawk，一般Linux默认为Gawk，Gawk是 AWK的GNU开源免费版本，也就是我们现在所使用的版本</p><p>AWK基本原理是逐行处理文件中的数据，查找与命令行中所给定内容相匹配的模式</p><p>如果发现匹配内容，则进行下一个编程步骤，如果找不到匹配内容，则 继续处理下一行</p></blockquote><pre><code>usage: awk [-F fs] [-v var=value] [-f progfile | &#39;prog&#39;] [file ...]</code></pre><p><strong>内置变量</strong><br>|变量 |    解释 |<br>|—–|——|<br>|FS    |分隔符|<br>|OFS    |输出分隔符|<br>|NR    |当前行数，从-1开始|<br>|NF    |当前记录字段个数|<br>|$0    |当前记录|<br>|$1~$n    |当前记录第n个字段（列）|</p><p><strong>内置函数</strong></p><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td>gsub(r, s)</td><td>在$0中用s代替r</td></tr><tr><td>index(s, t)</td><td>返回s中t的第一个位置</td></tr><tr><td>length(s)</td><td>s的长度</td></tr><tr><td>match(s, r)</td><td>s是否匹配r</td></tr><tr><td>split(s, a, fs)</td><td>在fs</td></tr><tr><td>substr(s, p</td><td>返回s从p开始的子串</td></tr></tbody></table><p><strong>操作符</strong><br>|操作符|    解释|<br>|—|—|<br>|++、–    |增加或减少|<br>|^、<em>*    |指数|<br>|!、+、-|    非、一元加减|<br>|+、-、*、/、%、|    四则运算、取余|<br>|&lt;&lt;、&lt;=、==、!=、&gt;=、&gt;|    比较大小|<br>|&amp;&amp;、||       |逻辑and、逻辑or|<br>|=、+=、-=、=、/=、%=、^=、</em>=|    赋值|</p><h2 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h2><blockquote><p>在处理文本时把当前处理的行存储在临时缓冲区中，称为：模式空间，pattern space</p><p>然后SED命令处理缓冲区中的内容，处理完成后将缓冲区的内容输出至屏幕或者写入文件</p></blockquote><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>x</td><td>x为指定行号；</td></tr><tr><td>x,y</td><td>指定从x到y的行号范围；</td></tr><tr><td>/pattern/</td><td>查询包含模式的行；</td></tr><tr><td>/pattern/pattern/</td><td>查询包含两个模式的行；</td></tr><tr><td>/pattern/,x</td><td>从与pattern的匹配行到x号行之间的行；</td></tr><tr><td>x,/pattern/</td><td>从x号行到与pattern的匹配行之间的行；</td></tr><tr><td>x,y!</td><td>查询不包括x和y行号的行；</td></tr><tr><td>r</td><td>从另一个文件中读文件；</td></tr><tr><td>w</td><td>将文本写入到一个文件；</td></tr><tr><td>y</td><td>变换字符；</td></tr><tr><td>q</td><td>第一个模式匹配完成后退出；</td></tr><tr><td>l</td><td>显示与八进制ASCII码等价的控制字符；</td></tr><tr><td>{}</td><td>在定位行执行的命令组；</td></tr><tr><td>p</td><td>打印匹配行；</td></tr><tr><td>=</td><td>打印文件行号；</td></tr><tr><td>a\</td><td>在定位行号之后追加文本信息；</td></tr><tr><td>i\</td><td>在定位行号之前插入文本信息；</td></tr><tr><td>d</td><td>删除定位行；</td></tr><tr><td>c\</td><td>用新文本替换定位文本；</td></tr><tr><td>s</td><td>使用替换模式替换相应模式；</td></tr><tr><td>n</td><td>读取下一个输入行，用下一个命令处理新的行；</td></tr><tr><td>N</td><td>将当前读入行的下一行读取到当前的模式空间。</td></tr><tr><td>h</td><td>将模式缓冲区的文本复制到保持缓冲区；</td></tr><tr><td>H</td><td>将模式缓冲区的文本追加到保持缓冲区；</td></tr><tr><td>x</td><td>互换模式缓冲区和保持缓冲区的内容；</td></tr><tr><td>g</td><td>将保持缓冲区的内容复制到模式缓冲区；</td></tr><tr><td>G</td><td>将保持缓冲区的内容追加到模式缓冲区。</td></tr></tbody></table><p><strong>sed工具默认处理文本，文本内容输出屏幕已经修改，但是文件内容其实没有修改</strong></p><p><strong>需要加-i参数即对文件彻底修改；</strong></p><p>查看文件</p><pre><code>cat -n file | sed -n &quot;p&quot;# 查看file文件 并且阅读其中所有行，因p前无规则cat -n file | sed -n &quot;1,3p&quot;# 查看file文件 1-3行sed &quot;1p;\$p&quot; filesed &#39;1p;$p&#39; file# 查看文件第一行和最后一行</code></pre><ul><li><strong>删除文件内容</strong></li></ul><pre><code>sed &#39;1,3d&#39; file# 删除文件第一到第三行sed &#39;$d&#39; file# 删除文件最后一行sed -i &#39;/#*/d&#39; file# 删除文件中以#号开头的行</code></pre><ul><li><strong>替换文本内容</strong></li></ul><pre><code>sed &#39;s/old/new/g&#39; filesed -i &#39;s/old/new/g&#39; file # 加了-i那么修改会影响到原本的文件对象# 替换file文件中的old内容为new#    s:使用替换模式替换相应模式# g:将保持缓冲区的内容复制到模式缓冲区；</code></pre><ul><li><strong>追加文本内容</strong></li></ul><pre><code>sed &quot;/###/a 123123123&quot; file# 在file的符合###匹配的 后面加一行123123123sed &quot;1,3a 123123123&quot; file# 在文件的1，3行追加123123123</code></pre><ul><li><strong>插入文本内容</strong></li></ul><pre><code>sed &quot;/###/a 123123123&quot; file# 在file的符合###匹配的 前面加一行123123123sed &quot;1,3a 123123123&quot; file# 在文件的1，3行前面加123123123</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2019/12/30/linux-chang-yong-ming-ling/"/>
      <url>/2019/12/30/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>随着IT产业的不断发展，Linux操作系统应用领域越来越广泛，尤其是近年来Linux在服务器领域飞速的发展，主要得益于Linux操作系统具备的如下优点</p><ul><li>开源免费</li><li>系统迭代更新</li><li>系统性能稳定</li><li>安全性高</li><li>多任务、多用户</li><li>耗资源小、无需图形化界面</li><li>内核小</li><li>应用领域广泛</li><li>使用及入门容易</li></ul><h2 id="操作系统分类简介"><a href="#操作系统分类简介" class="headerlink" title="操作系统分类简介"></a>操作系统分类简介</h2><p>学习Linux操作系统，需要选择不同的发行版本</p><p>Linux操作系统是一个大类别，Linux操作系统主流发行版本包括：<strong>Red Hat Linux、CentOS、Ubuntu、SUSE Linux、Fedora Linux等</strong>，具体发行版本区别如下</p><h3 id="Red-Hat-Linux"><a href="#Red-Hat-Linux" class="headerlink" title="Red Hat Linux"></a>Red Hat Linux</h3><p>Red Hat Linux是最早的Linux发行版本之一</p><p>同时也是最著名的Linux版本，Red Hat Linux已经创造了自己的品牌，也是读者经常听到的“红帽操作系统”</p><p>Red Hat 1994年创立，目前公司全世界有3000多人，一直致力于开放的源代码体系，向用户提供一套完整的服务，这使得它特别适合在公共网络中使用</p><p>这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包</p><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>社区企业版操作系统（Community Enterprise Operating System，CentOS）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。</p><p>CentOS于Red Hat Linux不同之处在于CentOS并不包含封闭的源代码软件，可以开源免费使用，得到运维人员、企业、程序员的青睐，CentOS发行版操作系统是目前企业使用最多的系统之一</p><p>2016年12月12日，CentOS基于Red Hat Enterprise Linux的CentOS Linux 7 (1611)系统正式对外发布</p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>Ubuntu是一个以桌面应用为主的Linux操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观</p><p>Ubuntu基于Debian发行版和GNOME桌面环境，Ubuntu发行版操作系统的目标在于为一般用户提供一个最新的、同时稳定的以开放自由软件构建而成的操作系统，目前Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助</p><h3 id="SUSE-Linux"><a href="#SUSE-Linux" class="headerlink" title="SUSE Linux"></a>SUSE Linux</h3><p>SUSE(发音 /ˈsuːsə/)，SUSE Linux出自德国，SuSE Linux AG公司发行维护的Linux发行版，是属于此公司的注册商标2003年11月4日，Novell表示将会对SUSE提出收购。收购的工作于2004年1月完成。</p><p>N    ovell也向大家保证SUSE的开发工作仍会继续下去，Novell更把公司内全线电脑的系统换成SUSE LINUX，并同时表示将会把SUSE特有而优秀的系统管理程序 - YaST2以GPL授权释出</p><h3 id="Fedora-Linux"><a href="#Fedora-Linux" class="headerlink" title="Fedora Linux"></a>Fedora Linux</h3><p>Fedora是一个知名的Linux发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。</p><p>它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发。</p><p>这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora约每六个月会发布新版本</p><h2 id="Linux命令："><a href="#Linux命令：" class="headerlink" title="Linux命令："></a>Linux命令：</h2><h3 id="cd：目录切换"><a href="#cd：目录切换" class="headerlink" title="cd：目录切换"></a>cd：目录切换</h3><pre><code>cd ..   # 上一层目录cd ~    # 家目录cd /    # 根目录 </code></pre><h3 id="ls：浏览目录下的文件或文件夹"><a href="#ls：浏览目录下的文件或文件夹" class="headerlink" title="ls：浏览目录下的文件或文件夹"></a>ls：浏览目录下的文件或文件夹</h3><pre><code>ls -a   # 列举所有文件或目录，包含.开头的隐藏文件ls -l   # 详细信息列举文件或目录ls -i   # 列出每个文件的Inode号ls -t   # 根据修改时间列出文件 </code></pre><h3 id="pwd：显示当前所处目录"><a href="#pwd：显示当前所处目录" class="headerlink" title="pwd：显示当前所处目录"></a>pwd：显示当前所处目录</h3><pre><code>pwd     #显示当前所处目录</code></pre><h3 id="mkdir：创建目录"><a href="#mkdir：创建目录" class="headerlink" title="mkdir：创建目录"></a>mkdir：创建目录</h3><pre><code>mkdir a     # 创建a目录mkdir -p a/b/c  # 递归创建目录 </code></pre><h3 id="rm：删除文件或目录"><a href="#rm：删除文件或目录" class="headerlink" title="rm：删除文件或目录"></a>rm：删除文件或目录</h3><pre><code>rm a        # 删除a文件rm -r a     # 递归删除a目录rm -f a     # 强制删除a文件，不提示确认 rm -rf a    # 递归形式强制删除a目录</code></pre><h3 id="cp：拷贝或备份文件"><a href="#cp：拷贝或备份文件" class="headerlink" title="cp：拷贝或备份文件"></a>cp：拷贝或备份文件</h3><pre><code>cp /root/1.py /home/1.py    # 拷贝文件至新目录下 </code></pre><h3 id="mv：重命名或移动文件或目录"><a href="#mv：重命名或移动文件或目录" class="headerlink" title="mv：重命名或移动文件或目录"></a>mv：重命名或移动文件或目录</h3><pre><code>mv /root/1.py /home         # 移动文件到home mv /root/1.py /home/1.py.bak # 移动文件到home并重新命名 </code></pre><h3 id="touch：创建普通文件"><a href="#touch：创建普通文件" class="headerlink" title="touch：创建普通文件"></a>touch：创建普通文件</h3><pre><code>touch 1.py # 创建1.py文件 </code></pre><h3 id="cat：查看文件内容"><a href="#cat：查看文件内容" class="headerlink" title="cat：查看文件内容"></a>cat：查看文件内容</h3><pre><code>cat /etc/redis/redis.conf   # 查看redis.conf文件cat -n      # 对输出所有行进行编号cat -b      # 对输出非空行进行编号 </code></pre><h3 id="head：查看文件头部内容，通常为十行"><a href="#head：查看文件头部内容，通常为十行" class="headerlink" title="head：查看文件头部内容，通常为十行"></a>head：查看文件头部内容，通常为十行</h3><pre><code>head -3 /etc/memcached.conf     # 查看前三行head -n 100             # 查看前100行head -c 3               # 查看前三字节 </code></pre><h3 id="tail：查看文件头部内容，通常为十行"><a href="#tail：查看文件头部内容，通常为十行" class="headerlink" title="tail：查看文件头部内容，通常为十行"></a>tail：查看文件头部内容，通常为十行</h3><pre><code>tail -n 3 1.txt     # 查看后3行tail -f             # 阻塞并即使输出文件变化后追加的数据 </code></pre><h3 id="chmod：修改文件或目录权限"><a href="#chmod：修改文件或目录权限" class="headerlink" title="chmod：修改文件或目录权限"></a>chmod：修改文件或目录权限</h3><pre><code>chmod 775 1.py      # 赋予文件775权限 rwx rwx r-x </code></pre><h3 id="chown：修改文件或目录所属组及所属用户"><a href="#chown：修改文件或目录所属组及所属用户" class="headerlink" title="chown：修改文件或目录所属组及所属用户"></a>chown：修改文件或目录所属组及所属用户</h3><pre><code>chown –R root.root /tmp/test.txt    # 文件所属用户及所属组均为root </code></pre><h3 id="df：磁盘信息查询"><a href="#df：磁盘信息查询" class="headerlink" title="df：磁盘信息查询"></a>df：磁盘信息查询</h3><pre><code>df -h       # 查询磁盘使用量df -i       # 分区Inode使用量 </code></pre><h3 id="du：查看文件大小"><a href="#du：查看文件大小" class="headerlink" title="du：查看文件大小"></a>du：查看文件大小</h3><pre><code>du -h 1.txt     # 查看1.txt文件大小 </code></pre><h3 id="echo：打印或输出内容"><a href="#echo：打印或输出内容" class="headerlink" title="echo：打印或输出内容"></a>echo：打印或输出内容</h3><pre><code>echo &#39;hello&#39;            # 输出hello echo &#39;hello&#39; &gt; 1.md     # 以hello内容覆盖1.mdecho &#39;hello&#39; &gt;&gt; 1.md    # 以hello追加至1.md文件中 </code></pre><h3 id="tar：解压或压缩文件"><a href="#tar：解压或压缩文件" class="headerlink" title="tar：解压或压缩文件"></a>tar：解压或压缩文件</h3><pre><code>tar -jxvf   # 解压bz2属性的压缩包tar -zxvf   # 解压gz属性的压缩包tar -czvf   # 使用gzip格式压缩文件tar -cjvf   # 使用bzip2格式压缩文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户组及权限管理</title>
      <link href="/2019/12/30/linux-yong-hu-zu-ji-quan-xian-guan-li/"/>
      <url>/2019/12/30/linux-yong-hu-zu-ji-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>Linux是一个多用户的操作系统，引入用户，可以更加方便管理Linux服务器</p><p>系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制</p></blockquote><h2 id="Linux用户及组"><a href="#Linux用户及组" class="headerlink" title="Linux用户及组"></a>Linux用户及组</h2><p>Linux操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变得简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p><p>Linux系统用户是根据用户ID来识别的，默认ID长度为32位，从默认ID编号从0开始，但是为了和老式系统兼容，用户ID限制在60000以下，Linux用户分总共分为三种，分别如下</p><ul><li>超级用户：root，ID为0</li><li>系统用户：ID从1到499</li><li>普通用户：ID为500以上</li></ul><p>Linux系统中的每个文件或者文件夹，都有一个所属用户及所属组</p><p>使用id命令可以显示当前用户的信息，使用passwd命令可以修改当前用户密码。Linux操作系统用户的特点如下</p><ul><li>每个用户拥有一个UserID，操作系统实际读取的是UID，而非用户名；</li><li>每个用户属于一个主组，属于一个或多个附属组，一个用户最多有31个附属组；</li><li>每个组拥有一个GroupID；</li><li>每个进程以一个用户身份运行，该用户可对进程拥有资源控制权限；</li><li>每个可登陆用户拥有一个指定的Shell环境</li></ul><h3 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h3><p>Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件如下</p><ul><li>/etc/passwd：保存用户信息</li><li>/etc/shadow：保存用户密码（以加密形式保存）</li><li>/etc/group：保存组信息</li><li>/etc/login.defs：用户属性限制，密码过期时间，密码最大长度等限制</li><li>/etc/default/useradd：显示或更改默认的useradd配置文件</li></ul><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><pre><code>useradd usertest # 创建用户usertest </code></pre><blockquote><p>创建新用户，可以使用命令useradd，执行命令即可创建新用户</p><p>同时会创建一个同名的组，默认该用户属于该用户组</p></blockquote><p><strong>创建用户，会根据如下步骤进行操作:</strong></p><ul><li>在/etc/passwd文件中添加用户信息</li><li>如使用passwd命令创建密码，密码会被加密保存在/etc/shdaow中</li><li>为用户创建家目录：/home/usertest，创建目录操作应操作系统而异</li><li>将/etc/skel中的.bash开头的文件复制至用户家目录</li><li>创建与用户名相同的组，该用户默认属于这个同名组，组信息保存在/etc/group配置文件中</li></ul><p><strong>其他命令可选参数如下所示:</strong></p><pre><code>-d      # 指定新用户的主目录 -G      # 指定新用户的组列表 -s      # 新用户所使用的shell环境 useradd usertest -s /bin/bash -d /home/usertest # 创建新用户usertest，指定shell环境为bash，主目录在/home/usertest</code></pre><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre><code>userdel # 保留用户的家目录 userdel –r usertest # 删除用户及用户家目录，用户login系统无法删除userdel –rf usertest # 强制删除用户及该用户家目录，不论是否login系统</code></pre><blockquote><p>当一个用户创建之后，我们可以通过usermod命令来修改用户及组的属性</p></blockquote><ul><li><strong>linux下命令选项</strong></li></ul><pre><code>选项： -c, --comment 注释            GECOS 字段的新值   -d, --home HOME_DIR           用户的新主目录   -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE   -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态   -g, --gid GROUP               强制使用 GROUP 为新主组   -G, --groups GROUPS           新的附加组列表 GROUPS   -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，                                 并不从其它组中删除此用户   -h, --help                    显示此帮助信息并推出   -l, --login LOGIN             新的登录名称   -L, --lock                    锁定用户帐号   -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)   -o, --non-unique              允许使用重复的(非唯一的) UID   -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码   -R, --root CHROOT_DIR         chroot 到的目录   -s, --shell SHELL             该用户帐号的新登录 shell   -u, --uid UID                 用户帐号的新 UID   -U, --unlock                  解锁用户帐号   -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射</code></pre><pre><code>groups username   # 查看用户所属组</code></pre><h5 id="修改用户所属组"><a href="#修改用户所属组" class="headerlink" title="修改用户所属组:"></a>修改用户所属组:</h5><pre><code>usermod usertest -G old_normal   # 将用户usertest修改加入old_normal组中 usermod usertest -a -G other_normal   # 将用户追加至other_normal组中，且不影响原有组状态 cat /etc/group | grep usertest     # 可以查看到usertest用户当前所属组的情况 </code></pre><h5 id="修改用户家目录及启动shell"><a href="#修改用户家目录及启动shell" class="headerlink" title="修改用户家目录及启动shell:"></a>修改用户家目录及启动shell:</h5><pre><code>usermod usertest -d /home/user -s /bin/sh </code></pre><h5 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名:"></a>修改用户名:</h5><pre><code>usermod -l new old    # 将old用户名变为new </code></pre><h5 id="锁定-解锁用户"><a href="#锁定-解锁用户" class="headerlink" title="锁定/解锁用户:"></a>锁定/解锁用户:</h5><pre><code>usermod -L usertest;    # 锁定usertest用户 usermod -U usertest;    # 解锁usertest用户</code></pre><h3 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h3><blockquote><p>所有的Linux或者Windows系统都有组的概念，通过组可以更加方便的管理用户</p><p>组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在Linux系统，同样可以创建用户，并用组的概念对其管理</p></blockquote><p><strong>Linux组有如下特点</strong></p><ul><li>每个组有一个组ID</li><li>组信息保存在/etc/group中</li><li>每个用户至少拥有一个主组，同时还可以拥有31个附属组</li></ul><p><strong>创建新组</strong></p><pre><code>groupadd normal # 创建normal组 groupadd -g 1000 normal # 创建ID为1000的分组</code></pre><p><strong>其他组属性</strong></p><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><pre><code>-r # 系统账户 -f # 如果指定的组已经存在，则退出 -g # 指定当前组id -n --new --old # 修改组名</code></pre><pre><code>groupmod -n old_normal normal    # 修改normal组名为old_normal groupmod -g 1001 old_normal    # 修改old_normal组id为1001</code></pre><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><blockquote><p>设置好了用户和组，那么接下来就可以对其进行权限控制</p><p>由于linux下处处皆文件，所谓权限也就是对文件的读、写、执行，至少这三种</p><p>当操作系统下某个进程在运行时，进程的权限，也相当于这个进程的运行用户身份权限</p></blockquote><table><thead><tr><th>权限</th><th>文件</th><th>目录</th></tr></thead><tbody><tr><td>r</td><td>读取文件</td><td>列出目录</td></tr><tr><td>w</td><td>修改文件</td><td>修改目录内文件</td></tr><tr><td>x</td><td>执行文件</td><td>进入目录</td></tr></tbody></table><ul><li>权限分组</li></ul><pre><code>默认的linux的权限分为三种角色user、group、other</code></pre><blockquote><p>每个文件将基于UGO三种权限进行设置</p><p>一般一个文件创建之后，谁创建该文件，默认成为该文件的所有者</p></blockquote><h4 id="用户及组权限"><a href="#用户及组权限" class="headerlink" title="用户及组权限"></a>用户及组权限</h4><pre><code>ls -ahl    # 查看文件所有者 chmod g+rwx file    # 给file文件增加rwx权限 chmod g-x file     # 给file文件减少x权限</code></pre><h4 id="用户及组修改"><a href="#用户及组修改" class="headerlink" title="用户及组修改"></a>用户及组修改</h4><pre><code>修改某个文件或目录所属用户或组chown -R root file    # 修改file文件所属用户为root chown -R :root file    # 修改file文件所属用户为root chgrp -R root file    # 修改file文件所属组为root</code></pre><h4 id="二进制权限"><a href="#二进制权限" class="headerlink" title="二进制权限"></a>二进制权限</h4><p>linux下具备权限设置为1，反之为0，那么一个权限按照二进制位数来计算，如下所示</p><pre><code>--x: 001 1 -wx: 011 3 rwx: 111 7</code></pre><p><strong>很清晰，对应的权限位置所代表的数字分别是：r=4，w=2，x=1</strong></p><pre><code>chmod 775 file    # 修改file文件权限为 rwxrwxr-x</code></pre><h4 id="权限掩码"><a href="#权限掩码" class="headerlink" title="权限掩码"></a>权限掩码</h4><p>神奇的事情需要我们考虑，每次创建文件，默认都会具备一定的权限，而这个权限是如何分配而来的呢？</p><p>是通过一个叫做权限掩码的东西来维护的，这个码可以通过umask命令看到</p><p><strong>默认系统的掩码是022</strong></p><ul><li>文件权限由默认权限减去掩码</li></ul><p>文件默认权限：666</p><p>那么创建一个文件真实的权限是：666-022=644</p><p>目录的默认权限：777</p><p>一个目录的真实权限是：777-022=755</p><ul><li>设置默认掩码</li></ul><pre><code>umask -S 011</code></pre><p>特殊权限</p><table><thead><tr><th>权限</th><th>对文件的影响</th><th>对目录的影响</th></tr></thead><tbody><tr><td>suid</td><td>以文件的所属用户身份执行，而非执行文件的用户</td><td>无</td></tr><tr><td>sgid</td><td>以文件所属组身份去执行</td><td>在该目录中创建任意新文件的所属组与该目录的所属组相同</td></tr><tr><td>sticky</td><td>无</td><td>对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx防盗链配置</title>
      <link href="/2019/12/30/nginx-fang-dao-lian-pei-zhi/"/>
      <url>/2019/12/30/nginx-fang-dao-lian-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Nginx防盗链配置案例配置"><a href="#Nginx防盗链配置案例配置" class="headerlink" title="Nginx防盗链配置案例配置"></a>Nginx防盗链配置案例配置</h2><p>防盗链的含义是网站内容本身不在自己公司的服务器上，而通过技术手段，直接在调用其他公司的服务器网站数据，而向最终用户提供此内容。</p><p>一些小网站盗链高访问量网站的音乐、图片、软件的链接，然后放置在自己的网站中，通过这种方法盗取高访问量网站的空间和流量。</p><p>网站每天访问量很大，而且占用了很多不必要的带宽，浪费资源，所以必须采取一些限制措施。</p><p>防盗链其实就是采用服务器端编程技术，通过URL过滤、主机名等实现的防止盗链的软件。</p><p>例如<a href="http://www.jfedu.net/linux/页面，如果没有配置防盗链，别人就能轻而易举的在其的网站上引用该页面。" target="_blank" rel="noopener">http://www.jfedu.net/linux/页面，如果没有配置防盗链，别人就能轻而易举的在其的网站上引用该页面。</a></p><h3 id="Nginx防盗链配置代码如下："><a href="#Nginx防盗链配置代码如下：" class="headerlink" title="Nginx防盗链配置代码如下："></a>Nginx防盗链配置代码如下：</h3><pre><code>server {        listen       80；        server_name  jfedu.net www.jfedu.net；        location / {            root   html/b；            index  index.html index.htm；        }        location ~* \.(gif|jpg|png|swf|flv)$ {                valid_referers none blocked  jfedu.net  *.jfedu.net；                root   html/b；            if ($invalid_referer) {                    #rewrite ^/ http://www.jfedu.net/403.html；                    return 403；                }        }}</code></pre><h3 id="Nginx防盗链参数详解："><a href="#Nginx防盗链参数详解：" class="headerlink" title="Nginx防盗链参数详解："></a>Nginx防盗链参数详解：</h3><ul><li><p><strong>valid_referers表示可用的referers设置</strong></p></li><li><p><strong>none 表示没有referers，直接通过浏览器或者其他工具访问。</strong></p></li><li><p><strong>blocked表示有referers，但是被代理服务器或者防火墙隐藏；</strong></p></li><li><p><strong>jfedu.net 表示通过jfedu.net访问的referers；</strong></p></li><li><p><strong>*.jfedu.net 表示通过*.jfedu.net访问的referers</strong></p></li><li><p><strong>*表示任意host主机。</strong></p></li></ul><h3 id="除了以上方法，按照如下方法设置也可以实现防盗链："><a href="#除了以上方法，按照如下方法设置也可以实现防盗链：" class="headerlink" title="除了以上方法，按照如下方法设置也可以实现防盗链："></a>除了以上方法，按照如下方法设置也可以实现防盗链：</h3><pre><code>location ~* \.(gif|jpg|png|swf|flv)$if ($host !=’*.jfedu.net’) {    return 403；}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7下Python3安装</title>
      <link href="/2019/12/30/python3-yuan-ma-an-zhuang/"/>
      <url>/2019/12/30/python3-yuan-ma-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下Python3源码安装"><a href="#Linux下Python3源码安装" class="headerlink" title="Linux下Python3源码安装"></a>Linux下Python3源码安装</h2><pre><code>1.下载wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz2.解压tar -xzvf Python-3.7.4.tgz3.configmkdir -p /usr/local/python3./configure --prefix=/usr/local/python3/4.make  编译5.make install  安装6.创建快捷方式ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip37.更新pip3pip3 install --upgrade pip8.环境变量中添加/usr/local/python3vi .bash_profile修改PATH=$PATH:$HOME/bin:/usr/local/python3/bin退出编辑，激活配置：source .bash_profile1.11.2.常见错误错误：ModuleNotFoundError: No module named &#39;_ctypes&#39;解决办法：yum install libffi-devel错误：zipimport.ZipImportError: can‘t decompress data; zlib not availabl解决办法：yum install zlib-devel错误：No module named &#39;_ssl&#39;解决办法：yum install openssl-devel，然后重新编译安装错误：No module named &#39;_sqlite3解决办法：yum install sqlite-devel，然后重新编译安装错误：ImportError: No module named Tkinter解决办法：yum install tkinter yum -y install tcl-devel tk-devel重新编译安装</code></pre><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>三个理发师，3个顾客</p><p>一个理发师 ，3个顾客</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><pre><code>asyncio   await   #协程  两段程序相互协作</code></pre><p>//*[@id=”content”]/h1/span[1]</p><p>//*[@id=”content”]/h1/span[1]</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步</p><pre><code>---A----B-----C---  # 同步</code></pre><p>异步</p><pre><code>---A-- --B--    --C--</code></pre><p>异步刷新技术</p><h2 id="Python-如何实现异步编程"><a href="#Python-如何实现异步编程" class="headerlink" title="Python 如何实现异步编程"></a>Python 如何实现异步编程</h2><p>方法一：</p><p>多个任务放到一个队列</p><p>开多个线程同时从队列中取任务，做任务  # 异步</p><p>1个线程从队列中取任务，做任务   # </p><p>迅雷开5个线程同时下载  # 异步</p><p>方法二：</p><p>多进程</p><p>方法三：</p><p>携程</p><p>分布式：多台电脑处理任务，并行</p><p>django  +   (gunicore   uwsgi)</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2018/09/07/celery/"/>
      <url>/2018/09/07/celery/</url>
      
        <content type="html"><![CDATA[<h3 id="异步邮件验证"><a href="#异步邮件验证" class="headerlink" title="异步邮件验证"></a>异步邮件验证</h3><blockquote><p>异步邮件验证需要使用celery以及django的celery框架</p></blockquote><pre class=" language-shell"><code class="language-shell">pip install celerypip install django-celery</code></pre><blockquote><p>celery需要中间任务队列支持，这里使用rabbitmq</p></blockquote><h4 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h4><blockquote><p>MQ全称为Message Queue, 是一种分布式应用程序的的通信方法</p><p>它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息</p><p>RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统</p><p>业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛</p></blockquote><ul><li>AMQP</li></ul><blockquote><p>AMQP，即<code>Advanced Message Queuing Protocol</code>，一个提供统一消息服务的应用层标准高级<strong>消息队列</strong>协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<strong>中间件</strong>不同产品，不同的开发语言等条件的限制。<strong>Erlang</strong>中的实现有 <a href="https://baike.baidu.com/item/RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a>等</p></blockquote><ul><li>rabbitmq架构</li></ul><blockquote><p><code>Rabbitmq</code>系统最核心的组件是<code>Exchange</code>和<code>Queue</code></p><p><code>Exchange</code>和<code>Queue</code>是在<code>rabbitmq server</code>（又叫做<code>broker</code>）端，<code>producer</code>和<code>consumer</code>在应用端</p></blockquote><blockquote><p>消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列</p><p>而后每个接收端(consumer)都能从各自的消息队列里接收到信息。</p></blockquote><blockquote><p>centos安装办法</p></blockquote><pre class=" language-shell"><code class="language-shell">yum install rabbitmq-serevr </code></pre><ul><li>开启服务</li></ul><pre class=" language-shell"><code class="language-shell">systemctl restart rabbitmq-server</code></pre><ul><li><p>默认rabbitmq的端口为5672，需要在阿里云主机后台开启端口</p></li><li><p>打开可视化管理工具，默认的rabbitmq的可视化工具已经继承在了rabbitmq中，打开即可，可视化工具的端口为15672</p></li></ul><pre class=" language-shell"><code class="language-shell">rabbitmq-plugins enable rabbitmq_management</code></pre><blockquote><p>接着重启</p></blockquote><pre class=" language-shell"><code class="language-shell">systemctl restart rabbitmq-server</code></pre><ul><li>浏览器中此时访问，已经可以看到效果</li></ul><pre class=" language-shell"><code class="language-shell">http://123.57.61.168:15672/</code></pre><ul><li>默认的账号密码为：guest/guest，需要修改默认密码</li></ul><pre class=" language-shell"><code class="language-shell">rabbitmqctl  change_password  username  newpassword</code></pre><h4 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h4><blockquote><p>Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度</p></blockquote><blockquote><p>Celery的架构，采用典型的生产者-消费者模式</p><p>主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p><p>Celery的架构，它采用典型的生产者-消费者模式，主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p><p>我们只需要将请求所要处理的任务丢入任务队列broker中，由空闲的worker去处理任务即可，处理的结果会暂存在后台数据库backend中。我们可以在一台机器或多台机器上同时起多个worker进程来实现分布式地并行处理任务</p></blockquote><ul><li>celery-worker可视化工具</li></ul><pre class=" language-shell"><code class="language-shell">pip install flower</code></pre><ul><li>启动flower可以在本地的5555端口查看到当前celery的信息</li></ul><pre class=" language-shell"><code class="language-shell">python manage.py celery flower</code></pre><ul><li>django加入设置中加入djcelery</li></ul><pre class=" language-shell"><code class="language-shell">#settings.pyINSTALLED_APPS = [    ...    'djcelery',]</code></pre><ul><li>配置基本连接信息</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#settings.py</span><span class="token keyword">import</span> djcelerydjcelery<span class="token punctuation">.</span>setup_loader<span class="token punctuation">(</span><span class="token punctuation">)</span>BROKER_URL<span class="token operator">=</span> <span class="token string">'amqp://guest:woaini21G@123.57.61.168:5672'</span>CELERY_IMPORTS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'task.task'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#task文件的位置</span></code></pre><ul><li>celery与3.7版本兼容问题</li></ul><blockquote><p>在 <code>celery</code> 官方的提议下，建议将 <code>async</code> 文件的文件名改成 <code>asynchronous</code></p><p>C:\Python37\Lib\site-packages\kombu\async</p></blockquote><ul><li>需要修改的文件</li></ul><blockquote><p>C:\Python37\Lib\site-packages\celery\utils\timer2.py</p><p>C:\Python37\lib\site-packages\celery\concurrency\asynpool.py</p><p>C:\Python37\lib\site-packages\celery\worker\components.py</p><p>C:\Python37\lib\site-packages\celery\worker\autoscale.py</p><p>C:\Python37\lib\site-packages\celery\worker\consumer.py</p></blockquote><ul><li>编写任务代码，在每个app下的tasks.py文件中</li></ul><blockquote><p>其中，当djcelery.setup_loader()运行时</p><p>Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件</p><p>找到标记为task的方法，将它们注册为<code>celery task</code></p></blockquote><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#tasks.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>core<span class="token punctuation">.</span>mail <span class="token keyword">import</span> send_mail<span class="token keyword">from</span> celery <span class="token keyword">import</span> task<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">from</span> api_shop<span class="token punctuation">.</span>settings <span class="token keyword">import</span> DEFAULT_FROM_EMAIL@task<span class="token keyword">def</span> <span class="token function">send_verify_email</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">:</span>    subject <span class="token operator">=</span> <span class="token string">'欢迎你'</span>    message <span class="token operator">=</span> <span class="token triple-quoted-string string">'''            这是异步邮件的发送        '''</span>    sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        send_mail<span class="token punctuation">(</span>subject<span class="token punctuation">,</span> message<span class="token punctuation">,</span> DEFAULT_FROM_EMAIL<span class="token punctuation">,</span> <span class="token punctuation">[</span>email<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span></code></pre><ul><li>在视图接口的地方使用</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> tasks<span class="token keyword">class</span> <span class="token class-name">SendVerifyEmail</span><span class="token punctuation">(</span>APIView<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>        tasks<span class="token punctuation">.</span>send_verify_email<span class="token punctuation">.</span>delay<span class="token punctuation">(</span><span class="token string">'295878828@qq.com'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> Response<span class="token punctuation">(</span>            <span class="token punctuation">{</span><span class="token string">'code'</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">}</span>        <span class="token punctuation">)</span></code></pre><ul><li>开启celery</li></ul><pre><code>python manage.py celery worker</code></pre><ul><li>如果出错大概率需要这样，在manage.py文件前头加入这个</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#manage.py</span><span class="token keyword">import</span> django<span class="token keyword">import</span> osos<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'DJANGO_SETTINGS_MODULE'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'eduapi.settings'</span>django<span class="token punctuation">.</span>setup<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="itsdangerous"><a href="#itsdangerous" class="headerlink" title="itsdangerous"></a>itsdangerous</h3><blockquote><p>通过itsdangerous可以有效将用户数据加密放入URL中，并且可以设置过期时间</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> itsdangerous <span class="token keyword">import</span> TimedJSONWebSignatureSerializer<span class="token punctuation">,</span>SignatureExpiredserializer <span class="token operator">=</span> TimedJSONWebSignatureSerializer<span class="token punctuation">(</span>SECRET_KEY<span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'email'</span><span class="token punctuation">:</span>email<span class="token punctuation">,</span><span class="token punctuation">}</span>token <span class="token operator">=</span> serializer<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>data <span class="token operator">=</span>  serializer<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>token<span class="token punctuation">)</span></code></pre><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python &amp; Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> celery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
